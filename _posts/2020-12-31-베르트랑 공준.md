---
layout: post
title: "백준 4948 - 베르트랑 공준"
author: "asadal"
tags: ["python", "파이썬", "백준", "에라토스테네스의 체", "베르트랑 공준"]
comments: true
---

##### 문제

>베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.
>
>이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.
>
>예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17, 19, 23)
>
>자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오. 

##### 입력

>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하며, 한 줄로 이루어져 있다. (n ≤ 123456) 
>
>입력의 마지막에는 0이 주어진다.

##### 출력

> 각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.

관건은 시간 초과 피하기.

우직하게 `for`문을 돌리면 당연히 시간 제한에 걸린다. \'에라토스테네스의 체\'를 이해한다면 어렵지 않게 풀 수 있는 문제다. [골드바흐의 추측](https://asadal.github.io/%E1%84%80%E1%85%A9%E1%86%AF%E1%84%83%E1%85%B3%E1%84%87%E1%85%A1%E1%84%92%E1%85%B3%E1%84%8B%E1%85%B4-%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%B3%E1%86%A8/) 문제 풀이에서처럼, n이 입력될 때마다 소수를 찾는 함수를 돌리면 역시 시간 초과에 걸린다. 처음에 소수 리스트를 만들어놓고 n을 입력받으면 리스트의 해당 구간에서 소수 개수를 세면 된다.

풀이는 아래.

```python
def prime_list(n):
    p = [1] * (n+1)
    for i in range(2, int((n+1)**0.5)+1):
        if p[i] == 1:
            for j in range(i*2, n+1, i):
                p[j] = 0
    return p
p = prime_list(246913)
while True:
    n = int(input())
    if n == 0:
        break
    print(p[n+1:2*n+1].count(1))
```

[[문제 보기](https://www.acmicpc.net/problem/4948)]
